library(forecast)
library(mboost)
library(readr)
library(glmnet)
source("R//functions.R")
lambdas <- 10^seq(2, -3, by = -.1)
lasso_forecast = function(Y_or, Y, X, lambdas, h, ratio_start = 0.8) {
n_tot <- length(Y)
n_out <- ceiling(n_tot - ratio_start*n_tot)
ind_out <- seq(to = n_tot, by = 1, length = n_out)
Y_predicted = c(Y_or[ind_out[1]])
varimp_df = data.frame(rep(0, (ncol(X)+1)))
selected_var = c()
for(i in 1:n_out){
ind_in <- seq(from = 1, to = ind_out[i] - h, by = 1)
y_extra = c()
x_reg <- as.matrix(as.data.frame(X[head(ind_in,-1),])) # x independent t = 1, ..., T.in-h
x0_reg <- as.matrix(X[tail(ind_in,1),])
for(j in 1:h) {
# expanding window
y_dep <- append(Y[tail(ind_in,-j)], y_extra)
y_reg <- as.matrix(y_dep)
# finding m*
lasso_reg <- cv.glmnet(x_reg, y_reg,
alpha = 1, lambda = lambdas,
standardize = TRUE, nfolds = 5)
# Best
lambda_best <- lasso_reg$lambda.min
lasso_model <- glmnet(x_reg, y_reg, alpha = 1, lambda = lambda_best,
standardize = TRUE)
predictions_test <- predict(lasso_model, s = lambda_best,
newx = x0_reg)
y_predicted = unname(predictions_test)
cat("Selected lambda is: ", lambda_best, "\n")
# visualizing selected predictors varimp
#varimp_df_partial = data.frame(varimp(model_1))
#sum_reduction = sum(varimp_df_partial[,1])
#varimp_partial = varimp_df_partial[,1]/sum_reduction
#varimp_df = cbind(varimp_df, varimp_partial)
# visualizing selected predictors frequency
#selected_var = append(selected_var, list(model_1$xselect()))
# output
y_extra = append(y_extra, y_predicted)
}
Y_predicted = append(Y_predicted, Y_or[(ind_out[1]+i-(h))] + sum(y_extra))
print(i/n_out)
}
results <- list(forecast = Y_predicted
#varimp = varimp_df[,-1],
#selected = selected_var
)
return(results)
}
ridge_forecast = function(Y_or, Y, X, lambdas, h, ratio_start = 0.8) {
n_tot <- length(Y)
n_out <- ceiling(n_tot - ratio_start*n_tot)
ind_out <- seq(to = n_tot, by = 1, length = n_out)
Y_predicted = c(Y_or[ind_out[1]])
varimp_df = data.frame(rep(0, (ncol(X)+1)))
selected_var = c()
for(i in 1:n_out){
ind_in <- seq(from = 1, to = ind_out[i] - h, by = 1)
y_extra = c()
x_reg <- as.matrix(as.data.frame(X[head(ind_in,-1),])) # x independent t = 1, ..., T.in-h
x0_reg <- as.matrix(X[tail(ind_in,1),])
for(j in 1:h) {
# expanding window
y_dep <- append(Y[tail(ind_in,-j)], y_extra)
y_reg <- as.matrix(y_dep)
# finding m*
ridge_reg <- cv.glmnet(x_reg, y_reg,
alpha = 0, lambda = lambdas,
standardize = TRUE, nfolds = 5)
# Best
optimal_lambda <- ridge_reg$lambda.min
ridge_model <- glmnet(x_reg, y_reg, alpha = 0, lambda = optimal_lambda,
#                            family = 'gaussian', nlambda = 25,
standardize = TRUE)
predictions_test <- predict(ridge_model, s = optimal_lambda,
newx = x0_reg)
y_predicted = unname(predictions_test)
cat("Selected lambda is: ", optimal_lambda, "\n")
# visualizing selected predictors varimp
#varimp_df_partial = data.frame(varimp(model_1))
#sum_reduction = sum(varimp_df_partial[,1])
#varimp_partial = varimp_df_partial[,1]/sum_reduction
#varimp_df = cbind(varimp_df, varimp_partial)
# visualizing selected predictors frequency
#selected_var = append(selected_var, list(model_1$xselect()))
# output
y_extra = append(y_extra, y_predicted)
}
Y_predicted = append(Y_predicted, Y_or[(ind_out[1]+i-(h))] + sum(y_extra))
print(i/n_out)
}
results <- list(forecast = Y_predicted
#varimp = varimp_df[,-1],
#selected = selected_var
)
return(results)
}
X = read_csv('X.csv', col_names = T, progress = T)[,-c(1,2)]
Y_or = read.csv('Y_or.csv')[,3]
Y = read.csv('Y_or.csv')[-1,4]
X_lag = add_lags(X,Y)
Y_lag = tail(Y,-11)
Y_or_lag = tail(Y_or,-11)
names = colnames(X_lag)
colnames(X_lag) = 1:(dim(X_lag)[2])
v_in = 0.1
h_in = 1
Mstop_in = 50
ratio_start_lag = 0.75
ratio_start_in = .757
n_tot_lag <- length(Y_lag)
n_out_lag <- ceiling(n_tot_lag - ratio_start_lag*n_tot_lag)
ind_out_lag <- seq(to = n_tot_lag, by = 1, length = n_out_lag)
n_tot <- length(Y)
n_out <- ceiling(n_tot - ratio_start_in*n_tot)
ind_out <- seq(to = n_tot, by = 1, length = n_out)
SARIMA_bench = function(Y_or, Y, h, ratio_start = 0.8) {
n_tot <- length(Y)
n_out <- ceiling(n_tot - ratio_start*n_tot)
ind_out <- seq(to = n_tot, by = 1, length = n_out)
Y_arima = c(Y_or[ind_out[1]])
for(i in 1:n_out){
ind_in <- seq(from = 1, to = ind_out[i] - h, by = 1)
bench = arima(exp(Y_or[ 1:(ind_out[i] - h + 1) ]), c(1,1,0)
, seasonal = list(order = c(0,1,1), period = 12)
)
forecast_bench = forecast(bench, h)
y_predicted_bench = forecast_bench$mean[h]
y_predicted_arima = log(y_predicted_bench)
Y_arima = append(Y_arima, (y_predicted_arima))
print(i/n_out)
}
results <- list(benchmark = Y_arima)
return(results)
}
b_sarima_1 = SARIMA_bench(Y_or, Y, h=1, ratio_start = ratio_start_in)
length(b_sarima_1$benchmark)
b_lasso_1 = lasso_forecast(Y_or = Y_or_lag, Y = Y_lag,
X=X_lag,lambdas = lambdas, h=1, ratio_start = 0.75)
length(b_lasso_1$forecast)
plot(tail(Y_or,74),type = "l")
lines(b_sarima_1$benchmark,col="blue")
lines(b_lasso_1$forecast, col="red")
b_sarima_e_1 = evaluation(b_sarima_1$benchmark, Y_or, ind_out, "SARIMA h=1")
b_lasso_e_1 = evaluation(b_lasso_1$forecast, Y_or_lag, ind_out_lag, "lasso h=1")
SARIMA_bench = function(Y_or, Y, h, ratio_start = 0.8) {
n_tot <- length(Y)
n_out <- ceiling(n_tot - ratio_start*n_tot)
ind_out <- seq(to = n_tot, by = 1, length = n_out)
Y_arima = c(Y_or[ind_out[1]])
for(i in 1:n_out){
ind_in <- seq(from = 1, to = ind_out[i] - h, by = 1)
bench = arima(exp(Y_or[ 1:(ind_out[i] - h + 1) ]), c(1,1,0)
, seasonal = list(order = c(1,1,0), period = 12)
)
forecast_bench = forecast(bench, h)
y_predicted_bench = forecast_bench$mean[h]
y_predicted_arima = log(y_predicted_bench)
Y_arima = append(Y_arima, (y_predicted_arima))
print(i/n_out)
}
results <- list(benchmark = Y_arima)
return(results)
}
b_sarima_1 = SARIMA_bench(Y_or, Y, h=1, ratio_start = ratio_start_in)
b_sarima_e_1 = evaluation(b_sarima_1$benchmark, Y_or, ind_out, "SARIMA h=1")
b_lasso_e_1 = evaluation(b_lasso_1$forecast, Y_or_lag, ind_out_lag, "lasso h=1")
b_ridge_1 = ridge_forecast(Y_or = Y_or_lag, Y = Y_lag,
X=X_lag,lambdas = lambdas, h=1, ratio_start = 0.75)
length(b_ridge_1$forecast)
b_boost_1 = boosting_reg_aic(Y_or = Y_or_lag,Y = Y_lag, X_lag, v = v_in,
h = 1, ratio_start = 0.75,
Mstop = 50)
length(b_boost_1$forecast)
plot(tail(Y_or,74),type = "l")
lines(b_sarima_1$benchmark,col="blue")
lines(b_lasso_1$forecast, col="red")
lines(b_ridge_1$forecast, col="purple")
lines(b_boost_1$forecast, col="green")
b_sarima_e_1 = evaluation(b_sarima_1$benchmark, Y_or, ind_out, "SARIMA h=1")
b_lasso_e_1 = evaluation(b_lasso_1$forecast, Y_or_lag, ind_out_lag, "lasso h=1")
b_ridge_e_1 = evaluation(b_ridge_1$forecast, Y_or_lag, ind_out_lag, "ridge h=1")
b_boost_e_1 = evaluation(b_boost_1$forecast, Y_or_lag, ind_out_lag, "boost h=1")
sarima_1 = readRDS('objects\\sarima_1.RData')
X = read_csv('X.csv', col_names = T, progress = T)[,-c(1,2)]
library(readr)
library(ggplot2)
X = read_csv('X.csv', col_names = T, progress = T)[,-c(1,2)]
setwd('\\report')
X = read_csv('..\\X.csv', col_names = T, progress = T)[,-c(1,2)]
X = read_csv('..\\code_master.csv', col_names = T, progress = T)[,-c(1,2)]
source('..\\R\\functions.R')
source('functions\\func_sarima.R')
source('functions\\func_boost-ic.R')
source('functions\\func_lasso-cv.R')
source('functions\\func_ridge-cv.R')
source('functions\\func_elast-cv.R')
source("R\\functions.R")
library(forecast)
library(mboost)
library(readr)
library(glmnet)
library(ggplot2)
X = read_csv('X.csv', col_names = T, progress = T)[,-c(1,2)]
X = read_csv('X.csv', col_names = T, progress = T)[,-c(1,2)]
Y_or = read.csv('Y_or.csv')[,3]
date = as.Date(read.csv('Y_or.csv')[,1])
Y = read.csv('Y_or.csv')[-1,4]
plot.ts(Y_or)
plot.ts(Y)
Y_or = read.csv('Y_or.csv')[,2]
date = as.Date(read.csv('Y_or.csv')[,1])
Y = read.csv('Y_or.csv')[-1,3]
plot.ts(Y)
plot.ts(Y_or)
date
date = as.Date(read.csv('Y_or.csv')[,4])
date
X = read_csv('X.csv', col_names = T, progress = T)[,-c(1,2)]
Y_or = read.csv('Y_or.csv')[,2]
date = as.Date(read.csv('Y_or.csv')[,4])
Y = read.csv('Y_or.csv')[-1,3]
source("R\\functions.R")
ncol(X)
X_lag = add_lags(X,Y='n')
ncol(X_lag)
914*11
914*12
Y_lag = tail(Y,-11)
Y_or_lag = tail(Y_or,-11)
names = colnames(X_lag)
colnames(X_lag) = 1:(ncol(X_lag))
lambdas <- 10^seq(2, -3, by = -.1)
lasso_1 = lassocv_forecast(Y_or = Y_or_lag, Y = Y_lag,
X=X_lag,lambdas = lambdas, h=1, ratio_start = 0.75)
ratio_start_lag = 0.75
n_tot_lag <- length(Y_lag)
n_out_lag <- ceiling(n_tot_lag - ratio_start_lag*n_tot_lag)
ind_out_lag <- seq(to = n_tot_lag, by = 1, length = n_out_lag)
ratio_start_in = .757
ratio_start_lag = 0.75
n_tot_lag <- length(Y_lag)
n_out_lag <- ceiling(n_tot_lag - ratio_start_lag*n_tot_lag)
ind_out_lag <- seq(to = n_tot_lag, by = 1, length = n_out_lag)
n_tot <- length(Y)
n_out <- ceiling(n_tot - ratio_start_in*n_tot)
ind_out <- seq(to = n_tot, by = 1, length = n_out)
lambdas <- 10^seq(2, -3, by = -.1)
date[floor((length(Y_or)-1)*ratio_start_in)]
df_y = data.frame(Date = date,Y = Y_or)
ggplot(df_y, aes(Date, Y)) +
geom_line(size = 0.2, color = 'black') +
geom_vline(xintercept = date[floor((length(Y_or)-1)*ratio_start_in)],
linetype="dashed",
color = "red", size=0.6)  +
labs(title="Exportações Brasil para China",
x ="Data", y = "Log das Exportações (U$)")
df_forecast_1 = data.frame(Date = tail(date,74), Y = tail(Y_or,74),
sarima = sarima_1$benchmark,
lasso = lasso_1$forecast, ridge = ridge_1$forecast,
boost = boost_1$forecast, elast = elast_1$forecast)
lasso_1$forecast
length(lasso_1$forecast)
tail(Y_or,54)
plot(tail(Y_or,54))
plot(tail(Y_or,54), type="l")
lines(lasso_1$forecast, col="red")
boost_1 = boostic_forecast(Y_or = Y_or_lag,Y = Y_lag, X_lag, v = v_in,
h = 1, ratio_start = 0.75, Mstop = 50)
lines(boost_1$forecast, col="blue")
boost_1$varimp
boost_1$selected
names[660]
names[3183]
names[4657]
names[10694]
tail(X[,660],54)
lines(tail(X[,660],54),col="blue")
plot(tail(X[,660],54), type="l")
plot(as.vector(tail(X[,660],54)), type="l")
as.vector(tail(X[,660],54))
as.vector(tail(X[,660],54))
tail(X[,660],54)
X[,660]
tail(X[,660],54)
as.vector(tail(X[,660],54))
test = tail(X[,660],54)
test
as.vector(test)
X[,660]
X[,1]
X[,666]
plot(X[,666])
plot.ts(X[,666])
plot.ts(tail(X[,660],54))
n_tot <- length(Y)
n_tot
ratio_start=0.75
n_tot <- length(Y)
n_out <- ceiling(n_tot - ratio_start*n_tot)
ind_out <- seq(to = n_tot, by = 1, length = n_out)
Y_predicted = c(Y_or[ind_out[1]])
varimp_df = data.frame(rep(0, (ncol(X)+1)))
selected_var = c()
v=0.1
h=1
i=1
ind_in <- seq(from = 1, to = ind_out[i] - h, by = 1)
y_extra = c()
x_reg <- X[head(ind_in,-1),] # x independent t = 1, ..., T.in-h
x0_reg <- matrix(X[tail(ind_in,1),], nrow = 1)
j=1
ind_i
ind_in
library(urca)
ur.df(Y, type = "drift")
summary(ur.df(Y, type = "drift"))
summary(ur.df(Y_or, type = "drift"))
plot.ts(Y)
ur.df(Y, type="none")
summary(ur.df(Y, type="none"))
summary(ur.df(Y, type="trend"))
summary(ur.df(Y, type="drift"))
summary(ur.df(diff(Y), type="drift"))
summary(ur.df(Y, type="drift"))
summary(ur.df(Y_or, type="drift"))
plot(Y)
plot(Y_or, type="l")
ind_in
ind_in <- seq(from = 1, to = ind_out[i] - h, by = 1)
y_extra = c()
x_reg <- X[head(ind_in,-1),] # x independent t = 1, ..., T.in-h
x0_reg <- matrix(X[tail(ind_in,1),], nrow = 1)
# expanding window
y_dep <- append(Y[tail(ind_in,-j)], y_extra)
y_reg <- as.matrix(y_dep)
# finding m*
model_1 = glmboost(y_reg ~ ., data = x_reg,
family = Gaussian(),
control = boost_control(mstop = Mstop, nu = v),
center = T)
x_reg
ncol(X)
nrow(X)
X = X_lag
n_tot <- length(Y)
n_out <- ceiling(n_tot - ratio_start*n_tot)
ind_out <- seq(to = n_tot, by = 1, length = n_out)
Y_predicted = c(Y_or[ind_out[1]])
varimp_df = data.frame(rep(0, (ncol(X)+1)))
selected_var = c()
ind_in <- seq(from = 1, to = ind_out[i] - h, by = 1)
y_extra = c()
x_reg <- X[head(ind_in,-1),] # x independent t = 1, ..., T.in-h
x0_reg <- matrix(X[tail(ind_in,1),], nrow = 1)
# expanding window
y_dep <- append(Y[tail(ind_in,-j)], y_extra)
y_reg <- as.matrix(y_dep)
# finding m*
model_1 = glmboost(y_reg ~ ., data = x_reg,
family = Gaussian(),
control = boost_control(mstop = Mstop, nu = v),
center = T)
Mstop = 50
# finding m*
model_1 = glmboost(y_reg ~ ., data = x_reg,
family = Gaussian(),
control = boost_control(mstop = Mstop, nu = v),
center = T)
AIC = AIC(model_1, method = "corrected" , df = "actset")
x0_reg_df = data.frame(t(data.frame(unlist(x0_reg))))
colnames(x0_reg_df) = colnames(x_reg)
y_predicted = unname(predict(model_1[mstop(AIC)], newdata = x0_reg_df,
type = "response")[1,1])
cat("Selected M is: ", mstop(AIC), "\n")
# visualizing selected predictors varimp
varimp_df_partial = data.frame(varimp(model_1))
sum_reduction = sum(varimp_df_partial[,1])
varimp_partial = varimp_df_partial[,1]/sum_reduction
varimp_df = cbind(varimp_df, varimp_partial)
# visualizing selected predictors frequency
selected_var = append(selected_var, list(model_1$xselect()))
# output
y_extra = append(y_extra, y_predicted)
varimp_df
varimp_partial
max(varimp_partial)
order(varimp_partial, decreasing = T)
names[head(order(varimp_partial, decreasing = T),18)]
ind_in
x_reg
ncol(x_reg)
nrow(x_reg)
order(varimp_partial, decreasing = T)
head(order(varimp_partial, decreasing = T),18)
head(order(varimp_partial, decreasing = T),19)
head(order(varimp_partial, decreasing = T),18)
names(head(order(varimp_partial, decreasing = T),18))
names[head(order(varimp_partial, decreasing = T),18)]
test = c(1,2,3)
tail(test,-1)
Y = tail(Y_or, -1)
length(Y)
nrow(X)
Y = tail(Y_or, -12)
length(Y)
length(Y_or)
Y_or = read.csv('Y_or.csv')[,2]
length(Y_or)
X = read_csv('X.csv', col_names = T, progress = T)[,-c(1,2)]
nrow(X)
length(Y_or)
length(Y)
Y = read.csv('Y_or.csv')[-1,3]
length(Y)
X = head(read_csv('X.csv', col_names = T, progress = T)[,-c(1,2)],-1)
nrow(X)
length(Y_or)
length(Y)
X = head(read_csv('X.csv', col_names = T, progress = T)[,-c(1,2)],-1)
Y_or = read.csv('Y_or.csv')[,2]
date = as.Date(read.csv('Y_or.csv')[,4])
Y = read.csv('Y_or.csv')[-1,3]
Y = tail(Y_or, -1)
length(Y)
nrow(X)
X_lag = add_lags(X,Y='n')
Y_lag = tail(Y,-11)
nrow(X_lag)
length(Y_lag)
X = X_lag
Y = Y_lag
n_tot <- length(Y)
n_out <- ceiling(n_tot - ratio_start*n_tot)
ind_out <- seq(to = n_tot, by = 1, length = n_out)
Y_predicted = c(Y_or[ind_out[1]])
varimp_df = data.frame(rep(0, (ncol(X)+1)))
selected_var = c()
i=1
ind_in <- seq(from = 1, to = ind_out[i] - h, by = 1)
y_extra = c()
x_reg <- X[head(ind_in,-1),] # x independent t = 1, ..., T.in-h
x0_reg <- matrix(X[tail(ind_in,1),], nrow = 1)
n_tot <- length(Y)
n_out <- ceiling(n_tot - ratio_start*n_tot)
ind_out <- seq(to = n_tot, by = 1, length = n_out)
Y_predicted = c(Y_or[ind_out[1]])
varimp_df = data.frame(rep(0, (ncol(X)+1)))
selected_var = c()
i=1
ind_in <- seq(from = 1, to = ind_out[i] - h, by = 1)
y_extra = c()
x_reg <- X[head(ind_in,-1),] # x independent t = 1, ..., T.in-h
x0_reg <- matrix(X[tail(ind_in,1),], nrow = 1)
j=1
n_tot <- length(Y)
n_out <- ceiling(n_tot - ratio_start*n_tot)
ind_out <- seq(to = n_tot, by = 1, length = n_out)
Y_predicted = c(Y_or[ind_out[1]])
varimp_df = data.frame(rep(0, (ncol(X)+1)))
selected_var = c()
ind_in <- seq(from = 1, to = ind_out[i] - h, by = 1)
x_reg <- X[head(ind_in,-1),] # x independent t = 1, ..., T.in-h
x0_reg <- matrix(X[tail(ind_in,1),], nrow = 1)
h
h=12
# expanding window
y_dep <- append(Y[tail(ind_in,-h)], y_extra)
y_reg <- as.matrix(y_dep)
# finding m*
model_1 = glmboost(y_reg ~ ., data = x_reg,
family = Gaussian(),
control = boost_control(mstop = Mstop, nu = v),
center = T)
names = colnames(X_lag)
colnames(X_lag) = 1:(ncol(X_lag))
X = X_lag
ind_in <- seq(from = 1, to = ind_out[i] - h, by = 1)
x_reg <- X[head(ind_in,-1),] # x independent t = 1, ..., T.in-h
x0_reg <- matrix(X[tail(ind_in,1),], nrow = 1)
# expanding window
y_dep <- append(Y[tail(ind_in,-h)], y_extra)
y_reg <- as.matrix(y_dep)
# finding m*
model_1 = glmboost(y_reg ~ ., data = x_reg,
family = Gaussian(),
control = boost_control(mstop = Mstop, nu = v),
center = T)
length(y_reg)
nrow(x_reg)
nrow(x_reg)-12
nrow(x_reg)-11
